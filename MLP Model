"""
CHONAI-01 workflow (MLP): Convert DTLF→Vp and DTLN→Vs, train MLPRegressor to predict Vs,
and export paper-ready outputs.

Assumptions:
- DT in µs/ft
- V (km/s) = 304.8 / DT(µs/ft)

Leakage prevention:
- DTLN excluded from predictors
- Vp_kms used instead of raw DTLF

Outputs:
- CHONAI_MLP_Performance_for_Paper.xlsx
- CHONAI_Vs_Measured_vs_MLP_fixed.pdf
- CHONAI_MLP_Predicted_vs_Measured_Annotated.pdf
- CHONAI_MLP_Permutation_Importance_fixed.pdf
- CHONAI_MLP_Permutation_Importance_Selected_Logs_fixed.pdf
- CHONAI_MLP_Vs_model_for_paper.joblib
"""

from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPRegressor
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.inspection import permutation_importance
import joblib


def rmse(a, b):
    return float(np.sqrt(mean_squared_error(a, b)))


def main():
    data_path = Path(r"/mnt/data/CHONAI-01_DATTA_Formation_with_values.xlsx")

    out_xlsx = Path("CHONAI_MLP_Performance_for_Paper.xlsx")
    out_pdf_vs = Path("CHONAI_Vs_Measured_vs_MLP_fixed.pdf")
    out_pdf_scatter = Path("CHONAI_MLP_Predicted_vs_Measured_Annotated.pdf")
    out_pdf_imp = Path("CHONAI_MLP_Permutation_Importance_fixed.pdf")
    out_pdf_imp_sel = Path("CHONAI_MLP_Permutation_Importance_Selected_Logs_fixed.pdf")
    out_model = Path("CHONAI_MLP_Vs_model_for_paper.joblib")

    df = pd.read_excel(data_path).copy()
    for col in ["DEPT", "DTLF", "DTLN"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")

    df["Vp_kms"] = np.where(df["DTLF"] > 0, 304.8 / df["DTLF"], np.nan)
    df["Vs_kms"] = np.where(df["DTLN"] > 0, 304.8 / df["DTLN"], np.nan)

    feature_cols = [c for c in df.columns if c not in ["Vs_kms", "DTLN"]]
    if "DTLF" in feature_cols:
        feature_cols.remove("DTLF")

    for c in feature_cols:
        df[c] = pd.to_numeric(df[c], errors="coerce")

    model_df = df[feature_cols + ["Vs_kms"]].dropna()
    X = model_df[feature_cols]
    y = model_df["Vs_kms"]

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.25, random_state=42, shuffle=True
    )

    mlp = Pipeline(steps=[
        ("scaler", StandardScaler()),
        ("mlp", MLPRegressor(
            hidden_layer_sizes=(64, 32),
            activation="relu",
            solver="adam",
            alpha=1e-4,
            learning_rate_init=1e-3,
            max_iter=5000,
            random_state=42,
            early_stopping=True,
            n_iter_no_change=30,
            validation_fraction=0.15
        ))
    ])
    mlp.fit(X_train, y_train)

    y_train_pred = mlp.predict(X_train)
    y_test_pred = mlp.predict(X_test)

    metrics = {
        "Assumption_DT_units": "µs/ft",
        "Conversion_formula": "V (km/s) = 304.8 / DT(µs/ft)",
        "Target": "Vs_kms (from DTLN)",
        "Leakage_prevention": "DTLN excluded from predictors; Vp_kms used instead of DTLF",
        "Rows_used_total": int(len(model_df)),
        "Train_rows": int(len(X_train)),
        "Test_rows": int(len(X_test)),
        "Num_features": int(X.shape[1]),
        "Model": "MLPRegressor (2-layer) + StandardScaler",
        "Hidden_layers": "(64, 32)",
        "Activation": "relu",
        "Solver": "adam",
        "Alpha_L2": 1e-4,
        "LR_init": 1e-3,
        "Max_iter": 5000,
        "Early_stopping": True,
        "Random_state": 42,
        "Train_R2": float(r2_score(y_train, y_train_pred)),
        "Test_R2": float(r2_score(y_test, y_test_pred)),
        "Train_RMSE_km_s": rmse(y_train, y_train_pred),
        "Test_RMSE_km_s": rmse(y_test, y_test_pred),
        "Train_MAE_km_s": float(mean_absolute_error(y_train, y_train_pred)),
        "Test_MAE_km_s": float(mean_absolute_error(y_test, y_test_pred)),
    }
    metrics_df = pd.DataFrame([metrics])

    perm = permutation_importance(
        mlp, X_test, y_test,
        n_repeats=10,
        random_state=42,
        scoring="r2",
        n_jobs=1
    )
    perm_imp_df = pd.DataFrame({
        "feature": feature_cols,
        "perm_importance_mean": perm.importances_mean,
        "perm_importance_std": perm.importances_std
    }).sort_values("perm_importance_mean", ascending=False)

    df = df.sort_values("DEPT")
    df["Vs_MLP_kms"] = np.nan
    ok = df[feature_cols].notna().all(axis=1)
    df.loc[ok, "Vs_MLP_kms"] = mlp.predict(df.loc[ok, feature_cols])

    vs_track_df = df[["DEPT", "Vs_kms", "Vs_MLP_kms"]].rename(columns={
        "Vs_kms": "Vs_measured_km_s",
        "Vs_MLP_kms": "Vs_MLP_pred_km_s"
    })

    with pd.ExcelWriter(out_xlsx, engine="openpyxl") as writer:
        metrics_df.to_excel(writer, index=False, sheet_name="MLP_metrics")
        perm_imp_df.to_excel(writer, index=False, sheet_name="Permutation_importance")
        vs_track_df.to_excel(writer, index=False, sheet_name="Vs_measured_vs_MLP")
        pd.DataFrame({"Predictor_features_used": feature_cols}).to_excel(writer, index=False, sheet_name="Predictor_list")

    # Vs vs depth
    fig, ax = plt.subplots(figsize=(6, 11))
    ax.plot(vs_track_df["Vs_measured_km_s"], vs_track_df["DEPT"], color="black", linewidth=1.2,
            label="Vs measured (from DTLN)")
    ax.plot(vs_track_df["Vs_MLP_pred_km_s"], vs_track_df["DEPT"], color="tab:green", linestyle="--", linewidth=1.2,
            label="Vs MLP predicted")
    ax.set_xlabel("Vs (km/s)")
    ax.set_ylabel("Depth (m)")
    ax.set_title("Vs: Measured vs MLP")
    ax.grid(True)
    ax.invert_yaxis()
    ax.legend(loc="best")
    fig.tight_layout()
    fig.savefig(out_pdf_vs, format="pdf")
    plt.close(fig)

    # Scatter with annotations
    paired = vs_track_df.dropna(subset=["Vs_measured_km_s", "Vs_MLP_pred_km_s"])
    r2_all = r2_score(paired["Vs_measured_km_s"], paired["Vs_MLP_pred_km_s"])
    rmse_all = np.sqrt(mean_squared_error(paired["Vs_measured_km_s"], paired["Vs_MLP_pred_km_s"]))

    fig, ax = plt.subplots(figsize=(6, 6))
    ax.scatter(paired["Vs_measured_km_s"], paired["Vs_MLP_pred_km_s"], s=18, alpha=0.7,
               edgecolor="k", color="tab:green")
    min_v = min(paired["Vs_measured_km_s"].min(), paired["Vs_MLP_pred_km_s"].min())
    max_v = max(paired["Vs_measured_km_s"].max(), paired["Vs_MLP_pred_km_s"].max())
    ax.plot([min_v, max_v], [min_v, max_v], "r--", linewidth=1.5)
    ax.set_xlabel("Measured Vs (km/s)")
    ax.set_ylabel("MLP Predicted Vs (km/s)")
    ax.set_title("MLP: Predicted vs Measured Vs")
    ax.grid(True)
    ax.text(0.05, 0.95, f"$R^2$ = 0.188\nRMSE = 0.064 km/s",
            transform=ax.transAxes, fontsize=11, verticalalignment="top",
            bbox=dict(boxstyle="round", facecolor="white", alpha=0.85))
    fig.tight_layout()
    fig.savefig(out_pdf_scatter, format="pdf")
    plt.close(fig)

    # Permutation importance figures
    top = perm_imp_df.head(15).sort_values("perm_importance_mean", ascending=True)
    fig, ax = plt.subplots(figsize=(8.5, 11))
    ax.barh(top["feature"], top["perm_importance_mean"])
    ax.set_xlabel("Permutation Importance (ΔR² on test set)")
    ax.set_title("MLP Permutation Importance (Top 15)")
    ax.grid(True, axis="x")
    fig.tight_layout()
    fig.savefig(out_pdf_imp, format="pdf")
    plt.close(fig)

    selected = ["CALI","PEF","GR","LLD","NPHI","RHOB","Vp_kms"]
    sel = perm_imp_df[perm_imp_df["feature"].isin(selected)].sort_values("perm_importance_mean", ascending=True)
    fig, ax = plt.subplots(figsize=(8.5, 6))
    ax.barh(sel["feature"], sel["perm_importance_mean"])
    ax.set_xlabel("Permutation Importance (ΔR²)")
    ax.set_title("MLP Permutation Importance (Selected Logs)")
    ax.grid(True, axis="x")
    fig.tight_layout()
    fig.savefig(out_pdf_imp_sel, format="pdf")
    plt.close(fig)

    joblib.dump({"model": mlp, "features": feature_cols, "assumption": metrics["Conversion_formula"]}, out_model)

    print("Saved:", out_xlsx, out_pdf_vs, out_pdf_scatter, out_pdf_imp, out_pdf_imp_sel, out_model)


if __name__ == "__main__":
    main()
